
# Домашнее задание к занятию "4.2. Использование Python для решения типовых DevOps задач"

## Обязательная задача 1

Есть скрипт:
```python
#!/usr/bin/env python3
a = 1
b = '2'
c = a + b
```

### Вопросы:
| Вопрос  | Ответ |
| ------------- | ------------- |
| Какое значение будет присвоено переменной `c`?  | будет ошибка, так как a это число, а b это строковые данные  |
| Как получить для переменной `c` значение 12?  | c = str(a) + b  |
| Как получить для переменной `c` значение 3?  | c = a + int(b)  |

## Обязательная задача 2
Мы устроились на работу в компанию, где раньше уже был DevOps Engineer. Он написал скрипт, позволяющий узнать, какие файлы модифицированы в репозитории, относительно локальных изменений. Этим скриптом недовольно начальство, потому что в его выводе есть не все изменённые файлы, а также непонятен полный путь к директории, где они находятся. Как можно доработать скрипт ниже, чтобы он исполнял требования вашего руководителя?

```python
#!/usr/bin/env python3

import os

bash_command = ["cd ~/netology/sysadm-homeworks", "git status"]
result_os = os.popen(' && '.join(bash_command)).read()
is_change = False
for result in result_os.split('\n'):
    if result.find('modified') != -1:
        prepare_result = result.replace('\tmodified:   ', '')
        print(prepare_result)
        break
```

### Ваш скрипт:
```python
#!/usr/bin/env python3

import os
bash_command = ["cd ~/SW/pycharm-community-2021.3.3/my_git01", "git status", "pwd"] #added path to files
result_os = os.popen(' && '.join(bash_command)).read()
pwd=result_os.split('\n') # added new variable for creating list with strings
#is_change = False - deleted extra variable
for result in result_os.split('\n'):
    if result.find('modified') != -1:
        
        prepare_result = result.replace('\tmodified   ', '')
        print(prepare_result, 'Location: ', pwd[-2])
        #break - deleted break for search process continue

```

### Вывод скрипта при запуске при тестировании:
```
leolex@leolex-VirtualBox:~$ ./4.2_2_script.py
/home/leolex/SW/pycharm-community-2021.3.3/my_git01
	modified:   README.md
	modified:   test.md
```

## Обязательная задача 3
1. Доработать скрипт выше так, чтобы он мог проверять не только локальный репозиторий в текущей директории, а также умел воспринимать путь к репозиторию, который мы передаём как входной параметр. Мы точно знаем, что начальство коварное и будет проверять работу этого скрипта в директориях, которые не являются локальными репозиториями.

### Ваш скрипт:
```python
#!/usr/bin/env python3

import os
import sys #добавил модуль sys чтобы передавать аргументы из командной строки
location = sys.argv[1] # запишем в переменную путь к репозиторию
bash_command = ["cd "+location, "git status", "pwd"] # добавил pwd чтобы вывести путь к файлам
result_os = os.popen(' && '.join(bash_command)).read()
#is_change = False - удалена лишняя переменная
for result in result_os.split('\n'):
    if result.find('modified') != -1:
        prepare_result = result.replace('\tmodified   ', '')
        print(location+prepare_result) #добавлен вывод location, в кторой есть пусть к файлам.
        #break - удалена остановка цикла после первого успешного результата

```

### Вывод скрипта при запуске при тестировании:
```
Запуск из директории, которая не является локальными репозиториями даёт ошибку
leolex@leolex-VirtualBox:~$ ./4.2_3_script.py ~
fatal: not a git repository (or any of the parent directories): .git

Запуск из директории локального репозитория
leolex@leolex-VirtualBox:~$ ./4.2_3_script.py ~/SW/pycharm-community-2021.3.3/my_git01
/home/leolex/SW/pycharm-community-2021.3.3/my_git01	modified:   README.md
/home/leolex/SW/pycharm-community-2021.3.3/my_git01	modified:   test.md
```

## Обязательная задача 4
1. Наша команда разрабатывает несколько веб-сервисов, доступных по http. Мы точно знаем, что на их стенде нет никакой балансировки, кластеризации, за DNS прячется конкретный IP сервера, где установлен сервис. Проблема в том, что отдел, занимающийся нашей инфраструктурой очень часто меняет нам сервера, поэтому IP меняются примерно раз в неделю, при этом сервисы сохраняют за собой DNS имена. Это бы совсем никого не беспокоило, если бы несколько раз сервера не уезжали в такой сегмент сети нашей компании, который недоступен для разработчиков. Мы хотим написать скрипт, который опрашивает веб-сервисы, получает их IP, выводит информацию в стандартный вывод в виде: <URL сервиса> - <его IP>. Также, должна быть реализована возможность проверки текущего IP сервиса c его IP из предыдущей проверки. Если проверка будет провалена - оповестить об этом в стандартный вывод сообщением: [ERROR] <URL сервиса> IP mismatch: <старый IP> <Новый IP>. Будем считать, что наша разработка реализовала сервисы: `drive.google.com`, `mail.google.com`, `google.com`.

### Ваш скрипт:
```python
!/usr/bin/env python3

import sys
import socket
import time

delay = 5
origip = {'drive.google.com': '0.0.0.0', 'google.com': '0.0.0.0', 'mail.google.com': '0.0.0.0'}
i = 1
n = 0
hostlist = origip.keys()
hostvalues = origip.values()

while True:
 for h in origip:
    newip = socket.gethostbyname(h) 
    if newip != origip[h] and i==1 and n != 1:
        print(' [ERROR] ' + str(h) + ' IP mismatch: ' +origip[h]+ ' ' +newip)
    origip[h]=newip
 i += 1
 if i >= 100:
   break
 time.sleep(delay)

```

### Вывод скрипта при запуске при тестировании:
```
leolex@leolex-VirtualBox:~$ ./4.2_4_script.py
 [ERROR] drive.google.com IP mismatch: 0.0.0.0 142.250.150.194
 [ERROR] google.com IP mismatch: 0.0.0.0 173.194.220.138
 [ERROR] mail.google.com IP mismatch: 0.0.0.0 173.194.222.83

```

## Дополнительное задание (со звездочкой*) - необязательно к выполнению

Так получилось, что мы очень часто вносим правки в конфигурацию своей системы прямо на сервере. Но так как вся наша команда разработки держит файлы конфигурации в github и пользуется gitflow, то нам приходится каждый раз переносить архив с нашими изменениями с сервера на наш локальный компьютер, формировать новую ветку, коммитить в неё изменения, создавать pull request (PR) и только после выполнения Merge мы наконец можем официально подтвердить, что новая конфигурация применена. Мы хотим максимально автоматизировать всю цепочку действий. Для этого нам нужно написать скрипт, который будет в директории с локальным репозиторием обращаться по API к github, создавать PR для вливания текущей выбранной ветки в master с сообщением, которое мы вписываем в первый параметр при обращении к py-файлу (сообщение не может быть пустым). При желании, можно добавить к указанному функционалу создание новой ветки, commit и push в неё изменений конфигурации. С директорией локального репозитория можно делать всё, что угодно. Также, принимаем во внимание, что Merge Conflict у нас отсутствуют и их точно не будет при push, как в свою ветку, так и при слиянии в master. Важно получить конечный результат с созданным PR, в котором применяются наши изменения. 

### Ваш скрипт:
```python
???
```

### Вывод скрипта при запуске при тестировании:
```
???
```

# Домашнее задание к занятию "4.1. Командная оболочка Bash: Практические навыки"

## Обязательная задача 1

Есть скрипт:
```bash
a=1
b=2
c=a+b
d=$a+$b
e=$(($a+$b))
```

Какие значения переменным c,d,e будут присвоены? Почему?

| Переменная  | Значение | Обоснование |
| ------------- | ------------- | ------------- |
| `c`  | a+b  | Переменная "c" определена неявно, в "с" записывается строка "a+b" |
| `d`  | 1+2  | Переменные "a" и "b" определены неявно, в "d" записывается строка состоящая из значений a и b "1+2"  |
| `e`  | 3    | за счет скобок команда интерпретируется как выполнение арифметической операции со значениями переменных  |


## Обязательная задача 2
На нашем локальном сервере упал сервис и мы написали скрипт, который постоянно проверяет его доступность, записывая дату проверок до тех пор, пока сервис не станет доступным (после чего скрипт должен завершиться). В скрипте допущена ошибка, из-за которой выполнение не может завершиться, при этом место на Жёстком Диске постоянно уменьшается. Что необходимо сделать, чтобы его исправить:
```bash
while ((1==1)
do
	curl https://localhost:4757
	if (($? != 0))
	then
		date >> curl.log
	fi
done
```

### Ваш скрипт:
```bash
while ((1==1)) #тут добавляется закрывающая скобка ) в конце
do
	curl https://localhost:4757
	if (($? != 0))
	then
		date >> curl.log
	else break # добавляем выход из цикла	
	fi
	timeout 3 # интервал проверки раз в 3 секунды, чтобы не забивать логи
done
```

## Обязательная задача 3
Необходимо написать скрипт, который проверяет доступность трёх IP: `192.168.0.1`, `173.194.222.113`, `87.250.250.242` по `80` порту и записывает результат в файл `log`. Проверять доступность необходимо пять раз для каждого узла.

### Ваш скрипт:
```bash
host=(192.168.0.1:80 173.194.222.113:80 87.250.250.242:80)
n=0
while (($n<5))
do
date >>curl.log
        for i in ${host[@]}
        do
                curl -s $i >/dev/null
                if (($? != 0))
                then
                echo $i status=$? >> curl.log
                fi
        done
        let "n +=1"
done

или

#!/usr/bin/env bash
addr=( 192.168.0.1:80 173.194.222.113:80 87.250.250.242:80 )
for n in {1..5}
do
date >>curl.log
        for i in ${addr[@]}
        do
                curl -s $i >/dev/null
                echo $i status=$? >>curl.log

        done
done

```

## Обязательная задача 4
Необходимо дописать скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным. Если любой из узлов недоступен - IP этого узла пишется в файл error, скрипт прерывается.

### Ваш скрипт:
```bash
host=(192.168.0.1:80 173.194.222.113:80 87.250.250.242:80)
n=0
while (($n == 0))
do
date >>curl.log
        for i in ${host[@]}
        do
                curl -s $i >/dev/null
                n=$?
                if (($n != 0))
                then
                        echo $i status=$n >> curl.log
                fi
        done
done
```

## Дополнительное задание (со звездочкой*) - необязательно к выполнению

Мы хотим, чтобы у нас были красивые сообщения для коммитов в репозиторий. Для этого нужно написать локальный хук для git, который будет проверять, что сообщение в коммите содержит код текущего задания в квадратных скобках и количество символов в сообщении не превышает 30. Пример сообщения: \[04-script-01-bash\] сломал хук.

### Ваш скрипт:
```bash
???
```
